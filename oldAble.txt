// copX, copY,
// left: displacement, heading
// Generative


// Music interactions:
/*
- copx - percussive synth with note from generative scale pings when copx threshold hit on either side
- synth holds at lowish level until threshold is passed again when release is triggered

- displacement:
- threshold triggers a sound which plays as long as displacement is above some threshold
- maybe as it gets closer back down to threshold, something about the synth changes?

- heading:
- this seems more like a value that will be used to indicate motions, rather than something that will be mapped raw?
- global frequency - open footed plays higher freq, opens up a filter etc..?


Generataive ideas:
- pick some melody (sequence of a few notes from scale) for one motion. Or maybe a few consonant melodies that can be iterated through (a phrase or a few phrases?)
- copx, displacement, etc... are responsible for deviating enough (but not too much) from that melody to make it interesting/not too repetitive
- deviation based on how long they've been doing that motion for - or how many notes triggered perhaps:
- motion change picks a new melody
- if

- Different but consonant/coordinated melodies for each sensor? Polyphonic melodies?
- Or is it better to have just one - perhaps more intuitive/less overwhelming

*/


Able {
	var <>motion; // lunge, squat, walk, balance, undefined, etc... -> SC symbols
	var <>motionTimer; // number of seconds that have elapsed since current motion has started
	var <>copX;   // an AbleSensor
	var <>copY;   // an AbleSensor

	var <>leftDisplacement;   // an AbleSensor
	var <>rightDisplacement;  // an AbleSensor

	var <>scale;  // list of midinotes the algorithm will pull from
	var <>runningSynths;
	var <>patterns;
	var <>melody; // a Melody
	var <> pythonRecvPort;

	var <>unrealNetAddr;

	var <> motions;
	var <> automaticMotions;
	classvar <> motions;

	*initClass{
		Able.motions = [\lunge,\squat,\walk,\stand];
	}

	*new{
		|motion=\undefined, copX, copY, leftDisplacement, rightDisplacement, scale,initialMelody, pythonRecvPort=10000, unrealIP="127.0.0.1", unrealPort=8000, automaticMotions=true|

		// TODO - set appropriate default thresholds
		if(copX.isNil,{copX= AbleSensor.new(threshold:0.5)});
		if(copY.isNil,{copY= AbleSensor.new(threshold:0.5)});

		if(leftDisplacement.isNil, {leftDisplacement = AbleSensor.new(threshold:0.5)});
		if(rightDisplacement.isNil, {rightDisplacement = AbleSensor.new(threshold:0.5)});

		if(scale.isNil,{scale = ((Scale.major.degrees)++(Scale.major.degrees+12)+48)});


		^super.new.init(motion, copX, copY, leftDisplacement, rightDisplacement, scale,initialMelody,pythonRecvPort,unrealIP, unrealPort, automaticMotions);
	}

	init{
		|motion, copX, copY, left, right, scale, initialMelody, pythonRecvPort,unrealIP, unrealPort, automaticMotions|
		this.motion = motion;
		this.motions = [this.motion];
		this.copX = copX;
		this.copY = copY;
		this.leftDisplacement = leftDisplacement;
		this.rightDisplacement = rightDisplacement;
		this.scale = scale;
		this.automaticMotions = automaticMotions;
		this.unrealNetAddr = NetAddr.new(unrealIP, unrealPort);

		if(initialMelody.isNil,{
			this.melody = Melody.generateMelody(this.scale);
		},{
			this.melody = initialMelody
		});

		this.pythonRecvPort = pythonRecvPort;

		this.runningSynths = Dictionary.new();
		this.patterns = Dictionary.new();
		this.motionTimer = Clock.seconds;
	}


	boot{
		CmdPeriod.removeAll();
		Server.default.options.memSize = 8192*16;

		Server.default.waitForBoot({
			this.initOsc();
			AbleSynths.loadSynths();
		});
	}



	initOsc{
		this.oscFuncs();

		CmdPeriod.add({this.oscFuncs});
	}


	oscFuncs {
		OSCFunc(this.handleCopX,"/cop/x",recvPort:this.pythonRecvPort);
		OSCFunc(this.handleCopY,"/cop/y",recvPort:this.pythonRecvPort);

		OSCFunc(this.handleMotionChange, "/label",recvPort:this.pythonRecvPort);

		OSCFunc(this.handleDisplacement(\left),"/left/displacement",recvPort:this.pythonRecvPort);
		OSCFunc(this.handleDisplacement(\right),"/right/displacement",recvPort:this.pythonRecvPort);

	}

	setMotion{
		|motion|
		if( Able.motions.includes(motion),{
			this.motion = motion;
			this.unrealNetAddr.sendMsg("/"++(this.motion.asString));
			this.runningSynths.do{
				|i|
				i.set(\gate,0);

			};
			this.patterns.do{|i| i.stop};
			//tODO - reset thresholds according to motion
			// if(this.motion ==\stand,{this.copX.threshold = Threshold(-0.9,0.9)}
		},{
			"unsupported motion type".warn;
		});
	}

	handleMotionChange{
		var f = {
			|msg|
			var newMotion = msg[1].asString.toLower.asSymbol;
			var lungeCount, walkCount, standCount, squatCount;
			var mostLikelyMotion;
			("Instantaneous motion: "++newMotion).postln;
			if( this.automaticMotions,{
				"(automatic enabled)".postln;
				if(Able.motions.includes(newMotion),{

					this.motions = this.motions.insert(0, newMotion).keep(5);


					lungeCount = this.motions.count({|v| v==\lunge})/this.motions.size;
					walkCount = this.motions.count({|v| v==\walk})/this.motions.size;
					squatCount = this.motions.count({|v| v==\squat})/this.motions.size;
					standCount =  this.motions.count({|v| v==\stand})/this.motions.size;
					[\lunge,\walk,\squat,\stand].postln;
					[lungeCount, walkCount, squatCount, standCount].postln;
					mostLikelyMotion = [lungeCount, walkCount, squatCount, standCount].indexOf(Utility.max([lungeCount, walkCount, squatCount, standCount]));
					mostLikelyMotion = [\lunge,\walk,\squat,\stand][mostLikelyMotion];

					if( (mostLikelyMotion != this.motion),{
						"new motion".postln;
						this.motion = mostLikelyMotion;

						this.unrealNetAddr.sendMsg("/"++(this.motion.asString));

						this.runningSynths.do{
							|i|
							i.set(\gate,0);
						};

						this.patterns.do{|i| i.stop};
					});
				},{
					"Invalid motion type received".warn;
				});
			});
		};
		^f;
	}


	handleCopX {
		var f = {
			|msg|
			var val = msg[1].asFloat;
			this.copX.push(val);

			switch(this.motion,
				\lunge, {this.copXLunge()},
				\squat, {this.copXSquat()},
				\walk, {this.copXWalk()},
				\stand, {this.copXStand()}
			);
		};
		^f;
	}

	copXLunge{

		if(this.copX.crossedThresholdIn,{
			var delta = this.copX.delta(10);
			if(this.runningSynths["copX"].notNil,{this.runningSynths["copX"].set(\gate,0)});
			"crossedThresholdInt".postln;
			this.copX.values.postln;
			(instrument:\kick_m,dur:delta.abs.linlin(0,1.5,4,8),midinote:this.melody.current+7).play;
		});

		if(this.copX.crossedThresholdOut,{
			var delta = this.copX.delta(15);
			if(this.runningSynths["copX"].notNil,{this.runningSynths["copX"].set(\gate,0)});
			this.runningSynths["copX"] = Synth(\motion,[
				\sustain, delta.abs.linlin(0,2,0.5,4),
				\fMotion, delta.abs/2,
				\freq, this.melody.next.midicps,
				\fPan, delta/2,
				\amp: -42.dbamp
			]);
			delta.postln;
		});

	}

	copXSquat{

	}

	copXWalk{
		this.copXLunge

	}

	copXStand{


		if (this.copX.crossedThresholdOut(),{
			var delta = this.copX.delta(15);
			this.patterns["copX"]=Pbindef(\copX,
				\instrument,\pressure,
				\midinote, Pseq(this.melody.notes%12+60,inf),
				\db,Pseq([Pseq((-20,-21..-100),1),Pseq([-100],inf)],inf),
				\dur,1/3/2
			).play;
			Pbindef(\copX2).stop;
			this.runningSynths["copX"] = Synth.new(\generic,[
				\freq: this.melody.current.midicps,
				\sustain: 4,
				\iPan: 0,
				\fPan: delta/2,
				\attack: delta.abs.linexp(0,2,2,0.001)
			]);
		},{
			if (this.copX.crossedThresholdIn(),{
				this.patterns["copX"]=Pbindef(\copX,
					\instrument,\pressure,
					\midinote, Pfunc({this.melody.next%12+60}),
					\db,Pseq([-20],inf),
					\dur,1/3/2
				).play;
				this.patterns["copX2"]=Pbindef(\copX2,
					\instrument,\generic,
					\midinote, Pfunc({Utility.min(this.melody.notes)%12+60}),
					\db,-48,
					\dur,4,
					\legato,1.3
				).play;
				if(this.runningSynths["copX"].notNil,{this.runningSynths["copX"].set(\gate,0)});
			});

		});



	}


	handleCopY {

		var f = {
			|msg|
			var val = msg[1].asFloat;
			this.copY.push(val);

			switch(this.motion,
				\lunge, {this.copYLunge()},
				\squat, {this.copYSquat()},
				\walk, {this.copYWalk()},
				\stand, {this.copYStand()}
			);

		};
		^f
	}

	copYLunge{
	}
	copYSquat{

	}
	copYStand{
	}
	copYWalk{
	}

	// Note this isn't an osc handler itself, it takes a value: 'left' or 'right'
	// and returns a function to be used as an osc handler.
	handleDisplacement {
		|foot|
		var func = {
			|msg|
			msg.postln;
		};
		^func;
	}

	changeScale{
		|scale|
		this.scale = scale;
		this.melody.setScale(this.scale);

	}
}


Melody {
	var <> notes; // list of notes in sequence
	var <> index; // current index in the list of notes
	var <> playCount; // number of times current melody has played. resets when notes change
	var <> mutateCount;
	var <> mutateEvery;
	var <> history; // list of lists of notes (old notes)
	var <> scale;

	*new{
		|notes, scale, mutateEvery|
		if(mutateEvery.isNil,{mutateEvery = inf});
		^super.new.init(notes, scale, mutateEvery);
	}

	init{
		|notes, scale, mutateEvery|
		this.mutateEvery = mutateEvery;
		this.notes = notes;
		this.scale = scale;
		this.index = 0;
		this.playCount = 0;
		this.history =[];
		this.mutateCount = 0;
	}

	setNotes{
		|notes|
		this.history = this.history.push(this.notes);
		this.notes = notes;
		this.playCount = 0;
	}

	next{
		var note = this.notes[this.index];
		this.index = (this.index+1);
		if(this.index>=this.notes.size,{
			this.index = 0;
			this.playCount = this.playCount+1;
			if(this.playCount%this.mutateEvery==0,{
				"mutate".postln;
				this.mutate();
			});
		});
		^note;
	}

	current{
		^this.notes[this.index];
	}

	mutate {
		var newNotes;
		var chances;
		var root, third, fifth, seventh;
		var newNote;

		this.history = this.history.add(this.notes);
		this.index = 0;
		this.playCount = 0;
		this.mutateCount = this.mutateCount + 1;
		newNotes = this.notes.copy;
		newNotes.removeAt(newNotes.size.rand);
		root = Utility.min(newNotes);
		third = this.scale[(this.scale.indexOf(root)+2)%this.scale.size];
		fifth = this.scale[(this.scale.indexOf(root)+4)%this.scale.size];
		seventh = this.scale[(this.scale.indexOf(root)+6)%this.scale.size];

		if (newNotes.includes(third) && newNotes.includes(fifth),{
			"musical match".postln;
			newNote = seventh;
		});

		if (newNotes.includes(fifth)&& newNotes.includes(third).not,{
			"musical match".postln;
			newNote = third;
		});


		if (newNotes.includes(third)&& newNotes.includes(fifth).not,{
			"musical match".postln;
			newNote = fifth;
		});





		if(newNote.isNil, {
			// Reduce probability of picking a note already in the melody

			chances = (1-(this.scale.collect({
				|i|
				var times = this.notes.count({|j|i==j});
				times

			})/this.notes.size)).normalizeSum;
			newNote = this.scale.wchoose(chances);
		});

		newNotes.insert((newNotes.size+1).rand, newNote);
		this.notes = newNotes;
	}

	*generateMelody {
		|scale, mutateEvery|
		var mel = [];
		wchoose([4,3,8],[4,2,1].normalizeSum).do{
			mel = mel.addFirst(scale.choose);
		};

		// if melody is only 4 notes, 50/50 chance that an altered version of 1st 4 will be 2nd
		// melody
		if(mel.size==4 && 2.rand == 1,{
			var altered = mel;
			var max = Utility.max(mel);
			var newNote = if(scale[scale.indexOf(max)].notNil,{
				scale[(scale.indexOf(max)+[1,-1].choose)%scale.size];
			},{scale.choose});
			altered[mel.indexOf(max)] = newNote;
			mel = mel++altered;
		});
		^Melody.new(mel, scale, mutateEvery);
	}
}


AbleSensor{

	var <>values; // array of values of length 'historySize'
	var <>foot; // left, right, or none (for things like copx)
	var <>threshold; //threshold obj.
	var <>historySize;

	*new{
		|values, foot, lowerThreshold, upperThreshold, historySize=20|
		if(foot.isNil,{foot = "none"});
		if(values.isNil,{values = []});

		^super.new.init(values,foot,lowerThreshold,upperThreshold,historySize);
	}

	init {
		|values, foot, lowerThreshold, upperThreshold, historySize|
		this.values = values;
		this.foot = foot;
		this.historySize = historySize;
		this.threshold = Threshold.new(lowerThreshold,upperThreshold);
	}

	push {
		|val|
		this.values = this.values.addFirst(val);
		this.values = this.values.keep(this.historySize);
	}

	delta{
		|frames = 1|
		^ if( this.values[0].isNil || this.values[frames].isNil,{0},{
			var movingAvg = this.values.copy;
			movingAvg.removeAt(0);
			movingAvg = movingAvg.keep(frames);
			this.values[0] - (movingAvg.mean);

		});
	}

	value{
		^ this.values[0];
	}

	outsideThreshold{
		^ this.threshold.outside(this.value);
	}

	insideThreshold{
		^ this.threshold.inside(this.value);
	}

	crossedThresholdOut{
		var inToOut,outToOut,nullFirst;
		var bool;
		if( this.values[0].isNil || this.values[1].isNil,{
			bool = false;
		},{
			inToOut = this.threshold.outside(this.values[0]) && this.threshold.inside(this.values[1]);
			outToOut = ((this.values[0]>this.threshold.upper) && (this.values[1] < this.threshold.lower)) || ((this.values[0] < this.threshold.lower) && (this.values[1]>this.threshold.upper));
			bool = inToOut || outToOut;

		});
		^bool;
	}


	crossedThresholdIn {
		var bool;
		if( this.values[0].isNil || this.values[1].isNil,{bool = false},{
			bool = this.insideThreshold && (this.threshold.outside(this.values[1]));
		});
		^bool;
	}

}

Threshold{
	var <>lower;
	var <>upper;

	*new{
		|lower,upper|
		^super.new.init(lower,upper);
	}

	init{
		|lower,upper|
		if(lower.isNil,{lower = -1*inf});
		if(upper.isNil,{upper = inf});
		if(upper<lower,{
			"upper must be <= lower".warn;
			lower = upper;
		});
		this.lower = lower;
		this.upper = upper;
	}

	outside{
		|val|
		^ (val<(this.lower)) || (val>(this.upper));
	}

	inside{
		|val|
		^ this.outside(val).not
	}
}

Utility {

	//uhg
	*max {
		|list|
		var max = list[0];
		list.do{
			|i|
			max = max(max,i);
		}
		^max;
	}

	*min{
		|list|
		var min = list[0];
		list.do{
			|i|
			min = min(min,i);
		}
		^min;
	}
}



AbleSynths{

	*loadSynths{
		var cmdp;
		~outBus = Bus.audio(Server.default,2).index;

		SynthDef(\kick_m,
			{
				|freq,amp,sustain,attack=0.01|

				var audio, arpegio,arpegioFreqEnv,arpegioEnv,arpegDur,noise3, soft,softEnv,noise,noise2;
				freq=freq/2;
				softEnv = EnvGen.ar(Env.perc(attackTime:0.2,releaseTime:sustain),doneAction:0);
				arpegDur = 1/5.5;

				// audio = PlayBuf.ar(1,kick,rate:0.5*(freq.cpsmidi%12).midiratio,doneAction:0);
				audio = SinOsc.ar(30)*EnvGen.ar(Env.perc(attack,sustain,curve:-8));
				audio = Mix.ar(audio);
				audio = LPF.ar(audio,100);
				audio = HPF.ar(audio,15);
				audio = audio * (-16.dbamp);

				noise3 = RHPF.ar(WhiteNoise.ar(-50.dbamp),freq:Line.kr(600,20000,dur:attack),rq:0.1)*Line.ar(1,0,sustain);

				soft = SinOsc.ar((1,1.001..1.004)*freq*Line.kr(4,4,sustain/8))*Line.ar(1,0,sustain);
				soft = Mix.ar(soft)*(-64.dbamp);

				noise = BPF.ar(
					WhiteNoise.ar,
					freq:[0,7,19,24,12,4,2,9,11,14,-12].midiratio*freq,
					rq:0.01);
				noise = Mix.ar(noise)*(-18.dbamp)*Line.ar(1,0,sustain*1.5);

				arpegioFreqEnv = EnvGen.kr(
					Env.circle(
						(0,7..200)
						.collect({|v,i|[v,v].clip(0,100)})
						.flatten.midiratio,times:[0.99,0.01]*arpegDur));
				arpegioEnv = EnvGen.ar(Env.circle([0,1,0],[0.001,0.999]*arpegDur));
				arpegio = SinOsc.ar(
					freq*arpegioFreqEnv+SinOsc.ar(freq*arpegioFreqEnv*16,
						mul:freq*8));
				arpegio = Mix.ar(arpegio)*(-16.dbamp)*arpegioEnv;
				arpegio = LPF.ar(arpegio,Clip.kr(freq,5,21000));
				arpegio = arpegio*Line.ar(1,0,dur:sustain)*Line.ar(1,0,dur:sustain);

				arpegio = arpegio+noise+soft+noise3;
				arpegio = Compander.ar(arpegio,audio,thresh:(-30.dbamp),slopeBelow:1,slopeAbove:1/3,clampTime:0.01,relaxTime:0.2);


				noise2 = [Dust.ar(Line.ar(200,50,dur:sustain)),Dust.ar(Line.ar(200,50,dur:sustain))]*Line.ar(1,0,sustain*4);
				noise2 = noise2*EnvGen.ar(Env.new([0,0,1,0],[0.34,0.1,sustain]))*(-30.dbamp);

				audio = audio +noise2+arpegio;

				audio = Compander.ar(audio,audio,-35.dbamp,slopeAbove:2,mul:12.dbamp)*amp*(-24.dbamp);
				DetectSilence.ar(audio,amp:0.0005,doneAction:2);
				Out.ar(~outBus,Pan2.ar(audio,0));
		}).add;



		SynthDef(\motion,
			{
				// expect motion as a value from 0 to 1
				|iMotion=0,fMotion=1,motionDur=1, freq = 220, amp = 0.1, pan = 0, gate = 0.25,sustain=1,iPan=0,fPan=0|
				var audio,env, smoothMotion, lfo;
				// var delayT = 0.1;
				var motion = Line.ar(iMotion,fMotion,motionDur);


				audio = Mix.ar(BPF.ar(WhiteNoise.ar,freq:([0,7,19,-12,-24,2,9,14,11,4].midiratio)*freq,rq:0.01)*0.25);


				lfo = SinOsc.ar(1/5,mul:50);
				audio = RLPF.ar(audio,400*motion.linexp(0,1,1,8)+lfo,rq:0.8);

				audio = HPF.ar(audio,freq:100);

				env = EnvGen.ar(Env.asr(),gate:gate,doneAction:2);

				audio = audio*env;//*motion;
				audio = Pan2.ar(audio,Line.kr(iPan,fPan,sustain));


				/*		6.do{
				audio = audio +DelayN.ar(audio,0.5,delayT,-3.dbamp);
				};*/
				Out.ar(0,audio);
		}).add;

		SynthDef(\generic,{
			|freq=440, amp=0.01, iPan=0, fPan=0,attack=0.5,gate=0.5, sustain=1,release=4|

			var audio,env,lfo, noise;
			var lfoDepth = 100;

			audio = Saw.ar(freq*([0,-12,7].midiratio)/2,mul:amp*[1,0.5])*(-8.dbamp);
			// audio = SinOsc.ar(freq,mul:amp);
			audio = Mix.ar(audio);//*SinOsc.ar(6+Rand(-0.1,0.1),mul:0.2,add:1);

			noise = BPF.ar(
				in:WhiteNoise.ar,
				freq:[12,19,24,36].midiratio*freq/2,rq:0.01,mul:-40.dbamp)*Line.kr(1,0,attack+(sustain)+(release/2));
			noise = Mix.ar(noise);

			audio = audio + noise;

			lfo = SinOsc.kr(0.6+Rand(-0.2,0.2),mul:lfoDepth,add:lfoDepth);

			audio = LPF.ar(audio,300+lfo);
			audio = HPF.ar(audio,10);

			env = EnvGen.ar(Env.asr(attackTime:attack,sustainLevel:1,releaseTime:2),gate:gate,doneAction:2);


			env = env*EnvGen.ar(Env.new([1,1,0],[attack+sustain,release]),doneAction:2);

			// env = EnvGen.ar(Env.perc(attackTime:attack,releaseTime:sustain+1),gate:gate,doneAction:2);

			audio = audio*env;
			audio = Pan2.ar(audio, Line.kr(iPan,fPan,attack));

			Out.ar(~outBus, audio);
		}).add;
		SynthDef(\pressure,
			{
				|freq = 440, amp = 0.1, pan = 0, mod =16,attack=0.01, release=1|

				var audio, modulator, env;
				var delayInterval = 0.25;
				var randMax = 0.25;
				var masterEnv;
				amp = amp*(6.dbamp);
				freq = freq *2;
				modulator = LPF.kr(SinOsc.kr(freq*16,mul:freq*4),20000);

				audio = SinOsc.ar(freq+modulator, mul:amp)*(-10.dbamp);
				env = EnvGen.ar(Env.perc(attack,release),doneAction:0);
				audio = audio *env;

				/*		3.do {
				|i|
				audio = audio +(DelayN.ar(audio,2, delayInterval+Rand(0,randMax), mul:-3.dbamp));
				};*/

				masterEnv = EnvGen.ar(Env.new([1,1],times:[delayInterval*3+attack+release+randMax]),doneAction:2);

				audio = HPF.ar(audio,4000);
				audio = audio * masterEnv;
				audio = Pan2.ar(audio,pan);

				Out.ar(0,audio);

		}).add;
		// master out synth
		SynthDef(\out,{
			|lpf=22000, hpf=10, mix=0,db=0|
			var audio = In.ar(~outBus,2)*(db.dbamp);
			var room = 20;
			var reverberated = GVerb.ar(audio,roomsize:room,earlyreflevel:0.1);
			audio = (mix.clip(0,1))*reverberated+((1-(mix.clip(0,1)))*audio);
			audio = LPF.ar(audio, Clip.kr(lpf,10,22000));
			audio = HPF.ar(audio,Clip.kr(hpf,10,22000));
			audio = Compander.ar(audio,audio,-30.dbamp,slopeAbove:1/2.5,mul:3.dbamp);
			audio = Compander.ar(audio,audio,thresh:-1.dbamp,slopeAbove:1/20);
			Out.ar(0,audio);
		}).add;

		Routine({
			1.wait;
			~out = Synth.new(\out);
		}).play;

		cmdp = {
			//WHY
			Routine({
				0.1.wait;
				~out = Synth.new(\out);
				"new out synth added".postln;
			}).play;
		};
		CmdPeriod.add(cmdp);
	}
}